local PASSIVE_SOURCES = {
	stars = {count = 1, multiplier = 1},
	planets = {count = 0, multiplier = 1},
	galaxies = {count = 0, multiplier = 1},
	-- Please add more resources types
}

function init(self)
	msg.post(".", "acquire_input_focus")
	self.cosmic_energy = 0
	self.energy_per_click = 1
	self.energy_per_second = 0
	self.base_energy_per_second = 0
	self.passive_multiplier = 1
	self.click_multiplier = 1
	self.base_passive_multiplier = 1
	self.base_click_multiplier = 1
	self.last_update_time = socket.gettime()
	self.save_time = nil
end

local function calculate_passive_energy(self)
	-- Calculate total passive energy per second from all sources
	local total_eps = 0

	-- Base passive generation
	total_eps = total_eps + self.base_energy_per_second

	-- Add contributions from different sources
	for source_name, source_data in pairs(PASSIVE_SOURCES) do
		total_eps = total_eps + (source_data.count * source_data.multiplier)
	end

	-- Apply all multipliers (base passive multiplier + evolution multiplier)
	self.energy_per_second = total_eps * self.passive_multiplier * self.base_passive_multiplier
end

local function add_passive_source(self, source_type, count, multiplier)
	if PASSIVE_SOURCES[source_type] then
		PASSIVE_SOURCES[source_type].count = PASSIVE_SOURCES[source_type].count + count
		if multiplier then
			PASSIVE_SOURCES[source_type].multiplier = PASSIVE_SOURCES[source_type].multiplier * multiplier
		end
		calculate_passive_energy(self)
	else
		print("Unknown passive source type: " .. source_type)
	end
end

local function handle_purchase(self, purchase_data)
	-- Check if player has enough energy
	if self.cosmic_energy >= purchase_data.cost then
		-- Deduct cost
		self.cosmic_energy = self.cosmic_energy - purchase_data.cost

		if purchase_data.resource_type == 'currency' then
			-- Currency type could only be: eps or clicker, later we need to introduce a boost.
			-- Favor is the actual item value to add, clicker or eps it does not matter
			if purchase_data.favor_type == 'eps' then
				self.base_energy_per_second = self.base_energy_per_second + purchase_data.favor
				calculate_passive_energy(self)
				print("Purchased eps item! Energy per second: " .. self.energy_per_second)
			else
				-- This is a clicker
				self.energy_per_click = self.energy_per_click + purchase_data.favor
				print("Purchased Better Clicker! Energy per click: " .. self.energy_per_click)
			end
			
		elseif PASSIVE_SOURCES[purchase_data.resource_type] then
			-- For now, every resource type counts x1
			print("We have a passive source?")
			add_passive_source(self, purchase_data.resource_type, 1, purchase_data.multiplier)
		else
			print("Unknown type!")
		end

-- 		-- Apply upgrade based on item name
-- 		if purchase_data.name == "Better Clicker" then
-- 			self.energy_per_click = self.energy_per_click + 1
-- 			print("Purchased Better Clicker! Energy per click: " .. self.energy_per_click)
-- 
-- 		elseif purchase_data.name == "Solar Panel" then
-- 			self.base_energy_per_second = self.base_energy_per_second + 5
-- 			self:calculate_passive_energy()
-- 			print("Purchased Solar Panel! Energy per second: " .. self.energy_per_second)
-- 
-- 		elseif purchase_data.item_name == "Energy Boost" then
-- 			self:activate_energy_boost(2, 3600) -- 2x boost for 1 hour
-- 			print("Purchased Energy Boost!")
-- 		end

		-- Notify GUI of successful purchase
		-- msg.post("/gui#gui", "purchase_success", {
		-- 	item_name = purchase_data.item_name
		-- })
	else
		-- -- Not enough energy
		-- msg.post("/gui#gui", "purchase_failed", {
		-- 	reason = "Not enough energy"
		-- })
		print("Not enough energy")
	end
end

local function recalculate_energy_values(self)
	-- Recalculate energy per click with all multipliers
	self.energy_per_click = 1 * self.base_click_multiplier * self.click_multiplier

	-- Recalculate passive energy with all multipliers
	calculate_passive_energy(self)
end

local function handle_star_evolution(self, evolution_data)
	-- Apply the evolution multipliers
	self.base_click_multiplier = evolution_data.click_multiplier
	self.base_passive_multiplier = evolution_data.passive_multiplier

	-- Recalculate energy values
	recalculate_energy_values(self)

	-- Show evolution message to player
	msg.post("/ui#game", "show_message", {
		text = "Evolved to " .. evolution_data.stage_name .. 
		"! " .. evolution_data.click_multiplier .. "x click energy, " ..
		evolution_data.passive_multiplier .. "x passive energy!"
	})

	print("Star evolved to stage " .. evolution_data.stage .. 
	": " .. evolution_data.stage_name)
end

function update(self, dt)
	calculate_passive_energy(self)
	-- Add passive energy
	local current_time = socket.gettime()
	local elapsed = current_time - self.last_update_time
	self.cosmic_energy = self.cosmic_energy + (self.energy_per_second * elapsed)
	self.last_update_time = current_time
	-- self.cosmic_energy = self.cosmic_energy + (self.energy_per_second * dt)
	-- Enviar actualización a la GUI
	msg.post("/ui#game", "update_energy", { 
		energy = self.cosmic_energy,
		passive_eps = self.energy_per_second,
		click_multiplier = self.base_click_multiplier * self.click_multiplier,
		passive_multiplier = self.base_passive_multiplier * self.passive_multiplier
	})

	msg.post("/star#star", "energy_updated", {
		energy = self.cosmic_energy
	})
end

local function set_base_passive_energy(self, amount)
	self.base_energy_per_second = amount
	calculate_passive_energy(self)
end

local function set_global_multiplier(self, multiplier)
	self.passive_multiplier = multiplier
	calculate_passive_energy(self)
end

function on_message(self, message_id, message)
	if message_id == hash("star_evolved") then
		handle_star_evolution(self, message)
	end

	if message_id == hash("purchase_item") then
		handle_purchase(self, message.item)
	end
end

function on_input(self, action_id, action)
	if action_id == hash("touch") and action.pressed then
		-- Detectar clic/tap en la partícula central
		local planet_pos = vmath.vector3(360, 640, 0)
		local planet_radius = 200
		local distance = vmath.length(vmath.vector3(
			action.x - planet_pos.x,
			action.y - planet_pos.y,
			0
		))
		if distance <= planet_radius then
			self.cosmic_energy = self.cosmic_energy + self.energy_per_click

			-- Enviar actualización a la GUI
			msg.post("/ui#game", "update_energy", { 
				energy = self.cosmic_energy,
				passive_eps = self.energy_per_second 
			})

			-- Enviar mensaje para efecto visual
			msg.post("/ui#game", "tap_effect", { position = action, energy_per_click = self.energy_per_click })

			return true
		end
	end
	
	return false
end
